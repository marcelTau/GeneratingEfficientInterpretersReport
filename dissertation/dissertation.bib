@article{structure_and_performance,
author = {Ertl, M. and Gregg, David},
year = {2003},
month = {11},
pages = {},
title = {The Structure and Performance of Efficient Interpreters.},
volume = {5},
journal = {J. Instruction-Level Parallelism}
}
@article{vmgen,
author = {Ertl, M. Anton and Gregg, David and Krall, Andreas and Paysan, Bernd},
title = {Vmgen: A Generator of Efficient Virtual Machine Interpreters},
year = {2002},
issue_date = {March 2002},
publisher = {John Wiley & Sons, Inc.},
address = {USA},
volume = {32},
number = {3},
issn = {0038-0644},
url = {https://doi.org/10.1002/spe.434},
doi = {10.1002/spe.434},
abstract = {In a virtual machine interpreter, the code for each virtual machine instruction has similarities to code for other instructions. We present an interpreter generator that takes simple virtual machine instruction descriptions as input and generates C code for processing the instructions in several ways: execution, virtual machine code generation, disassembly, tracing, and profiling. The generator is designed to support efficient interpreters: it supports threaded code, caching the top-of-stack item in a register, combining simple instructions into superinstructions, and other optimizations. We have used the generator to create interpreters for Forth and Java. The resulting interpreters are faster than other interpreters for the same languages and they are typically 2-10 times slower than code produced by native-code compilers. We also present results for the effects of the individual optimizations supported by the generator.},
journal = {Softw. Pract. Exper.},
month = {mar},
pages = {265–294},
numpages = {30},
keywords = {interpreter, byte code, stack architecture, generator, superinstruction, virtual machine}
}
@book{Pierce:SF1,
author = {Benjamin C. Pierce and Arthur Azevedo de Amorim and Chris Casinghino and Marco Gaboardi and Michael Greenberg and Cătălin Hriţcu and Vilhelm Sjöberg and Brent Yorgey},
editor = {Benjamin C. Pierce},
title = {"Logical Foundations"},
series = {"Software Foundations"},
volume = {"1"},
year = {"2023"},
publisher = {"Electronic textbook"},
}
@article{stack_caching_for_interpreters,
author = {Ertl, M. Anton},
title = {Stack Caching for Interpreters},
year = {1995},
isbn = {0897916972},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/207110.207165},
doi = {10.1145/207110.207165},
abstract = {An interpreter can spend a significant part of its execution time on accessing arguments of virtual machine instructions. This paper explores two methods to reduce this overhead for virtual stack machines by caching top-of-stack values in (real machine) registers. The dynamic method is based on having, for every possible state of the cache, one specialized version of the whole interpreter; the execution of an instruction usually changes the state of the cache and the next instruction is executed in the version corresponding to the new state. In the static method a state machine that keeps track of the cache state is added to the compiler. Common instructions exist in specialized versions for several states, but it is not necessary to have a version of every instruction for every cache state. Stack manipulation instructions are optimized away.},
booktitle = {Proceedings of the ACM SIGPLAN 1995 Conference on Programming Language Design and Implementation},
pages = {315–327},
numpages = {13},
location = {La Jolla, California, USA},
series = {PLDI '95}
}
@article{lua_implementation,
author = {Ierusalimschy, Roberto and Figueiredo, Luiz and Celes, Waldemar},
year = {2005},
month = {01},
pages = {1159-1176},
title = {The Implementation of Lua 5.0},
volume = {11},
journal = {J. UCS}
}
