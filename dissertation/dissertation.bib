@article{abstraction,
author = {Kahanwal, Brijender},
year = {2013},
month = {11},
pages = {},
title = {Abstraction Level Taxonomy of Programming Language Frameworks},
doi = {10.5121/ijpla.2013.3401}
}
@article{modern,
author = {Ertl, M. and Gregg, David},
year = {2001},
month = {11},
pages = {},
title = {The Behavior of Efficient Virtual Machine Interpreters on Modern Architectures},
isbn = {978-3-540-42495-6},
doi = {10.1007/3-540-44681-8_59}
}
@article{bebic,
  title={Operation DSL Making bytecode interpreters a walk in the park},
  author={Bebic, Nikola and Humer, Christian},
  year={2022}
}
@article{fang2016,
      title={A Performance Survey on Stack-based and Register-based Virtual Machines}, 
      author={Ruijie Fang and Siqi Liu},
      year={2016},
      eprint={1611.00467},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}
@article{structure_and_performance,
author = {Ertl, M. and Gregg, David},
year = {2003},
month = {11},
pages = {},
title = {The Structure and Performance of Efficient Interpreters.},
volume = {5},
journal = {J. Instruction-Level Parallelism}
}
@article{pascal,
author = {Bowles, Kenneth and Hollan, James},
year = {1978},
month = {07},
pages = {531-534},
title = {An introduction to the UCSD PASCAL system},
volume = {10},
journal = {Behavior Research Methods},
doi = {10.3758/BF03205341}
}
@article{superoperators,
author = {Proebsting, Todd A.},
title = {Optimizing an ANSI C Interpreter with Superoperators},
year = {1995},
isbn = {0897916921},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/199448.199526},
doi = {10.1145/199448.199526},
abstract = {This paper introduces superoperators, an optimization technique for bytecoded interpreters. Superoperators are virtual machine operations automatically synthesized from smaller operations to avoid costly per-operation overheads. Superoperators decrease executable size and can double or triple the speed of interpreted programs. The paper describes a simple and effective heuristic for inferring powerful superoperators from the usage patterns of simple operators.The paper describes the design and implementation of a hybrid translator/interpreter that employs superoperators. From a specification of the superoperators (either automatically inferred or manually chosen), the system builds an efficient implementation of the virtual machine in assembly language. The system is easily retargetable and currently runs on the MIPS R3000 and the SPARC.},
booktitle = {Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {322–332},
numpages = {11},
location = {San Francisco, California, USA},
series = {POPL '95}
}
@article{vmgen,
author = {Ertl, M. Anton and Gregg, David and Krall, Andreas and Paysan, Bernd},
title = {Vmgen: A Generator of Efficient Virtual Machine Interpreters},
year = {2002},
issue_date = {March 2002},
publisher = {John Wiley & Sons, Inc.},
address = {USA},
volume = {32},
number = {3},
issn = {0038-0644},
url = {https://doi.org/10.1002/spe.434},
doi = {10.1002/spe.434},
abstract = {In a virtual machine interpreter, the code for each virtual machine instruction has similarities to code for other instructions. We present an interpreter generator that takes simple virtual machine instruction descriptions as input and generates C code for processing the instructions in several ways: execution, virtual machine code generation, disassembly, tracing, and profiling. The generator is designed to support efficient interpreters: it supports threaded code, caching the top-of-stack item in a register, combining simple instructions into superinstructions, and other optimizations. We have used the generator to create interpreters for Forth and Java. The resulting interpreters are faster than other interpreters for the same languages and they are typically 2-10 times slower than code produced by native-code compilers. We also present results for the effects of the individual optimizations supported by the generator.},
journal = {Softw. Pract. Exper.},
month = {mar},
pages = {265–294},
numpages = {30},
keywords = {interpreter, byte code, stack architecture, generator, superinstruction, virtual machine}
}
@book{Pierce:SF1,
author = {Benjamin C. Pierce and Arthur Azevedo de Amorim and Chris Casinghino and Marco Gaboardi and Michael Greenberg and Cătălin Hriţcu and Vilhelm Sjöberg and Brent Yorgey},
editor = {Benjamin C. Pierce},
title = {"Logical Foundations"},
series = {"Software Foundations"},
volume = {"1"},
year = {"2023"},
publisher = {"Electronic textbook"},
}
@article{stack_caching_for_interpreters,
author = {Ertl, M. Anton},
title = {Stack Caching for Interpreters},
year = {1995},
isbn = {0897916972},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/207110.207165},
doi = {10.1145/207110.207165},
abstract = {An interpreter can spend a significant part of its execution time on accessing arguments of virtual machine instructions. This paper explores two methods to reduce this overhead for virtual stack machines by caching top-of-stack values in (real machine) registers. The dynamic method is based on having, for every possible state of the cache, one specialized version of the whole interpreter; the execution of an instruction usually changes the state of the cache and the next instruction is executed in the version corresponding to the new state. In the static method a state machine that keeps track of the cache state is added to the compiler. Common instructions exist in specialized versions for several states, but it is not necessary to have a version of every instruction for every cache state. Stack manipulation instructions are optimized away.},
booktitle = {Proceedings of the ACM SIGPLAN 1995 Conference on Programming Language Design and Implementation},
pages = {315–327},
numpages = {13},
location = {La Jolla, California, USA},
series = {PLDI '95}
}
@article{lua_implementation,
author = {Ierusalimschy, Roberto and Figueiredo, Luiz and Celes, Waldemar},
year = {2005},
month = {01},
pages = {1159-1176},
title = {The Implementation of Lua 5.0},
volume = {11},
journal = {J. UCS}
}
