\documentclass{article}
\title{Dissertation}
\author{
    Marcel Taubert  (mt652)\\
    20962335        \\
    \\
    School of Computing \\
    MSc Advanced Computer Science\\
    University of Kent \\
    \\
    Supervisor: Dr. Michael Vollmer
}
\usepackage{natbib,hyperref}
\date{\today}
\begin{document}
\maketitle
\clearpage

\section{Introduction}

%1. Introduction: objectives, intro to contents (overview)
    %- what is a vm interpreter
    %- how does a vm interpreter work
    %- difference between stack and register based vm
    %- what are optimizations, what optimizations are we using
    %- what kind of optimizations are there
    %- code generation (from a config file)
%3. description of the problem
    %- many parts of interpreter writing can be automated 
    %- why should we care about efficieny in interpreter
%6. literature and technology review, (what papers, vmgen??)
    %- what it says and how it relates to my project
%7. possible approaches and reason why we choose this approach
    %- by hand is hard
    %- doing it automatically
    %- what optimizations
    %- why rust not C (why others did it in C, what can you do in C)
    %- why for the Imp programming language
    %- why not compile to C code (2nd paper)
%8. description of work that we did 
    %- vm (stack, why tho)
    %- interpreter (visitor pattern)
    %- parser and scanner (not generated, why)
    %- bytecode design (why and how does it work)
    %- bytecode generator
    %- bytecode interpreter (visitor pattern)
    %- what is the input language
    %- optimizations (superinstructions, computed go-to)
    %- benchmark program
%10. Results: tests, benchmarks, what kind of programs
%11. Summary, Conclusion
%12. future work (automation)
%13. Bibliography

%/*
%What is an interpreter?
%- Programming is everywhere
%- 2 ways how code is run (compiler and interpreter)
%- whats good about interpreters
%*/

In the modern world we live in today, everything is controlled by code.
Everyone of us is using technology controlled by code, if they want it or not.
But not many people know how the code that programmers around the world write
gets executed on their device.


\subsection{What is an interpreter?}
In general there are two ways to execute code. Both approaches include the
process of translating the human readable code into something that the computer
can understand. 


During the first technique the code is compiled (translated) into machine code.
The end product is a stand alone program that can be executed at any time.


The second approach is called 'interpreting'. In this case the compiler does not
output machine code but produces a bytecode that will be executed by another
program (the interpreter).


Interpreters are generally easier to implement and have some other advantages
that makes them more approachable than compilers like portability or a fast
edit-compile-run cycle as stated by the authors of vmgen ~\cite{vmgen}. 

%/*
%what is a vm interpreter?
%- create intermediate representation that is similar to a real machine
%- series of bytecode instructions
%- (Frontend) compiler that produces this bytecode (written in rust)
%- (Backend) vm interpreter that executes the instructions
%- Some examples of vm interpreters (JVM, PVM (python))
%*/

\subsection{What is a virtual machine interpreter?}
A famous technique to implement interpreters is to build a virtual machine
interpreter. A vm interpreter is generally divided into two systems. A frontend
and a backend. ~\cite{vmgen}

The frontend consists of a compiler that takes the written code and produces a
sequence of bytecode instructions. The backend is a virtual machine that gets
the stream of bytecode instructions as input and executes them. ~\cite{vmgen}

The bytecode or intermediate representation used in a vm interpreter is usually
designed to be very similar to a real machine. ~\cite{vmgen}

Some real world examples of virtual machine interpreters are for example the
JVM (Java Virtual Machine) or the PVM (Python Virtual Machine). (TODO: link to them???)


\subsection{Virtual machine}
When we are talking about virtual machines we distinguish between stack based vm's and 
register based vm's.

Each of the version has it's advantages and disadvantages.

Stack based virtual machines are generally easier to implement than the register based approach.
That shows for example in the complexity of the intermediate representation used in the virtual 
machine. The stack based bytecode has a tendency of being smaller and by that more efficient in 
comparison to the rather complex bytecode instructions of the register based approach.

\begin{verbatim}
typical stack based instruction:
Push 1    -- push value to the stack
\end{verbatim}

\begin{verbatim}
typical register based instruction:
LD R1, 42 -- load value `42` into register R1
\end{verbatim}

This simplicity is the reason we have to decided to rely on a stack based virtual machine in
this paper.

\subsection{Optimizations}
When you are running your Java program the compiler does not just generate bytecode for
the JVM from your written code. The compiler will try it's best to optimize as much as possible
to ensure that the execution of the produced bytecode will be as fast as possible.
This optimization part of the compiler is by far one of the most crucial tasks of a compiler.

During the development of this project we have looked at a number of different
optimizations. Some of the optimizations that we have implemented for the
project are threaded code and peephole optimizations (superinstructions) (TODO:
SHOULD I EXPLAIN THEM HERE)


\subsection{Automation}
Writing an interpreter for a programming language can be a tedious and
challenging task on it's own. Thinking about how to keep the code efficient and
additionally implement optimizations makes it even harder.

One solution to this is automating the process of writing a virutal machine interpreter
by providing a configuration file.

\subsection{Objectives}
This paper will use the Rust programming language to build each part of a virtual machine 
interpreter with the optimal goal of automating the generation of it self depending on
a given configuration of a user.

We will explore techniques and approaches on how to build a vm interpreter in Rust and
use benchmarking to visualize results depending on applied optimizations.

\section{Description of the problem}
\subsection{Efficiency}
In terms of efficiency at run time of a program nativ compiled machine code
will always outperform the interpreted version. So why would we even care
about writing efficient interpreters and not just use native code compilers.

One of the main reasons interpreters are preferred over compilers is that 
native code compilers are more complex to develop and difficult to maintain.
~\cite{structure_and_performance}

Another big advantage of the interpreting approach is that compilers can only
generate native code for one target system while the virtual machine
interpreter stays the same on every system. By that the interpreter is portable
and the generated code does not depend on the underlaying machine.

\subsection{Automation}
Many programmers will come to the idea of implementing their own programming
language at some point in their career. Most of them will have noticed that
buidling an interpreter is a challenging task and requires a lot of work and
a clear structure. In addition to that it shows that many parts of an vm
interpreter are similar and repetitive. For example the code for executing 
VM instructions will be similar for most of the instructions. ~\cite{vmgen}

But what happens when the interpreter does not give the expected outcome in
terms of efficiency. It results in manual rewriting of a codebase just to
change the implementation of some part of the vm interpreter to see if the
performance increases.
Rewriting the whole interpreter to test if the performance is better using
a different development approach is not only time consuming but also error 
prone.

One solution to this problem is automation. The user should be able to provide
a configuration file and based on that we will generate an efficient vm 
interpreter. It will already use efficient implementation techniques and come
with built in optimizations. It also provides easy extensibility for the user
without needing to change any source code.

\section{Description of work}
The goal of this project is to build an virtual machine interpreter and 
explore the implementation of such in the Rust programming language.

\subsection{Tools used}
During the development of this project we used two programming languages. We
build the virtual machine and all parts of the interpreter in Rust and used 
Python to visualize any benchmarking results.

But why did we use Rust and not the C programming language like most other
systems do?
One reason for that is that as stated before most of the already existing
solutions are written in C and we wanted to explore something new.
Another reason why we decided to use Rust is that we were looking for a low level
systems programming language that allows us to work as efficient as possible
while still offering high level features like match statements and iterators.
An extension to that is Rust's expressive type system and strict memory
management rules which helps avoiding many kinds of errors that appear in 
standard C programming.

\subsection{VM} % stack based, show bytecode, reason about bytecode in rust enum
\subsection{Interpreter} % parser, scanner (not generated), 
\subsection{Optimizations} % explaination of the optimizations

\clearpage
\bibliographystyle{plain}
\bibliography{dissertation}
\end{document}

%what to do?
%write test programs, find superinstructions, do benchmarks, mandelbrot
%format of dis

