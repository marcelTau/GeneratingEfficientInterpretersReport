\documentclass{article}
\title{Critical Review of \texttt{vmgen}}
\author{
    Marcel Taubert  (mt652)\\
    20962335        \\
    \\
    School of Computing \\
    MSc Advanced Computer Science\\
    University of Kent \\
    \\
    Supervisor: Dr. Michael Vollmer
}
\usepackage{natbib,hyperref}
\date{\today}
\begin{document}
\maketitle
\clearpage

\section*{Introduction}
The following critical review will focus on the paper 'vmgen -- A Generator of
Efficient Virtual Machine Interpreters'. It was published by M. Anton Ertl,
David Gregg, Andreas Krall and Bernd Paysan in 2002.  

\section{Summary} To start with the paper explains why we should care about
interpreters and especially why we should care about how we can implement
efficient interpreters ~\cite{vmgen}. The authors state that interpreters are a
popular approach for implementing programming languages because of their ease
of implementation, portability and a fast edit-compile-run cycle ~\cite{vmgen}.
The next part of the paper focuses on automation by showing that many tasks of
building a VM interpreter are repetitive and thereby can be automated. The
authors specifically named the example of the execution of a VM instruction, VM
disassembly and VM code generation ~\cite{vmgen}. The following section of the
paper gives an overview of the vmgen program. The basic idea is that it
generates an efficient interpreter based on a configuration file that is
provided by the author of the programming language. It comes with many
optimizations enabled by default and allows users to specify their own
instructions and superinstructions (instructions that can be chained together).
During the configuration the user can specify C code that represents the
instruction and has access to powerful macros defined by vmgen like SET\_IP
which can directly set the instruction pointer. One of the earlier mentioned
optimizations is Top-of-stack caching which keeps the item on the top of the
stack in a register and by that reduces the number of loads from and stores to
a stack ~\cite{vmgen}. Another optimization is the peephole optimization where
at the beginning of every instruction it is checked if the current one can be
combined with the previous one into a superinstruction even if the previous
instruction already was a superinstruction. To demonstrate the results of vmgen
the authors implemented two interpreters ~\cite{vmgen}. The first one is Gforth
which is a portable implementation of Forth and the second one is a
threaded-code variant of the Cacao JVM JIT compiler. To compare the
interpreters generated by vmgen and the original ones the authors set up an
environment for benchmarking ~\cite{vmgen}. As a base there are different CPUs
with different architectures and then each interpreter is running several
programs to benchmark their runtime. In addition to the basic benchmarks the
authors also benchmarked different optimizations to see which optimization
works best on which architecture ~\cite{vmgen}. Vmgen is a great tool to
quickly generate efficient interpreters without needing to spend much time on
the repetitive parts of building an interpreter for a programming language. It
has optimizations built-in, and the performance is better than most of the
competing interpreters. 

\section{Critique}
Vmgen is a fantastic tool that helps you to quickly write a whole interpreter
for a programming language but there are a few things that could be changed
to improve the performance of the interpreter. 

The authors state that the whole application is written in C using the GNU Câ€™s
label-as-value feature to implement threaded code ~\cite{vmgen}. This is a
limitation to use GCC and reduces not only portability but also makes it
impossible to use other, potentionally better optimized, compilers. 

In addition to that I would question the authors if they thought about
implementing certain parts of the interpreter directly in assembly language.
This change would need more effort to stay portable but it would allow
optimizations that are simply not possible in C. By doing that, the performance
of the interpreter could be increased.

\section{Synthesis}
Since this paper was published in 2002 it would be interesting to see how the
benchmarks of today would look like compared to the ones in the paper. How
would the runtime behave on a new CPU from 2023 in comparison to 2002? The
CPUs used in the paper are running on 800MHz on the Athlon CPU and the other
ones are even slower going down to just 200MHz on the PPC 604e ~\cite{vmgen}.
Meanwhile the new Intel Core i9-13900K Processor has a maximal frequency of
5.80GHz.

The authors of the paper are using GCC 2.95. Meanwhile GCC version 13.1 is
published ~\cite{vmgen}. One way to further develop this research is to look at
what is new in GCC. If we would look at the new optimizations that GCC is
implementing now we could tune the vmgen program to output more optimal C code
which would lead to better optimizations when it is compiled down to assembly
and by that would improve the run-time of the interpreter.

Another extension to the project would be as stated in the critique to
implement certain parts of the interpreter or the whole interpreter directly in
assembly language and by that generate more efficient code. 
\clearpage
\bibliographystyle{plain}
\bibliography{review}
\end{document}
